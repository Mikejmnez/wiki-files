<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="en">
  <siteinfo>
    <sitename>OPeNDAP Documentation</sitename>
    <dbname>wikidb</dbname>
    <base>https://docs.opendap.org/index.php/Home</base>
    <generator>MediaWiki 1.38.4</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">OPeNDAP Documentation</namespace>
      <namespace key="5" case="first-letter">OPeNDAP Documentation talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>DAP4: Responses</title>
    <ns>0</ns>
    <id>725</id>
    <revision>
      <id>9277</id>
      <parentid>9270</parentid>
      <timestamp>2012-08-31T19:15:51Z</timestamp>
      <contributor>
        <username>Jimg</username>
        <id>3</id>
      </contributor>
      <origin>9277</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="18665" sha1="0a3b65m6wbnctfj9m67e7ovpyys3sbu" xml:space="preserve">[[Category:Development|Development]] [[Category:DAP4|DAP4]]
&lt;font size="+1" color="red"&gt;This is an old document that captures the starting point of the OPULS design work. It's out of date and should be referenced only as a baseline for the work.&lt;/font&gt;

[[OPULS_Development | &lt;-- back to OPULS Development]]

Author: [[User:Jimg|Jimg]], NDP, ?

== Overview ==

In response to DAP4 requests, a DAP4 system returns a chunked, multi-part MIME document containing the appropriate DAP4 response. This document describes the DAP4 responses, the manner in which they are bundled into MIME-Documents,  and the chunked response structure.

== Response Chunking ==

All DAP4 responses from a DAP4 server will be chunked, independently of any chunking utilized by protocols such as HTTP. This chunking is essentially is a message based communications scheme. Messages are sent in chunks and handled by the recipient. Out-of-band information can be passed via the extension chunks. The information contained in the extension chunks MAY be used to change the meaning/context of subsequent data chunks. For now we will only be sending Errors in the extension chunks.

[[DAP4 Chunking | The details of DAP4 Chunking are here.]]

This chunking schema provides the following desired outcomes:

# It provides a way for the server to send errors to the client in an out-of-band manner.
# It allows clients to know exactly how many bytes they can expect to read without a server (as opposed to a connection) error.
# It allows the client software to be in a position to deal with error messages as they arise, and easily locate the error content in the input stream.
# Because all messages are chunked, even errors generated by, say, the parseing of the constraint expression can be returned to the client in an error chunk (as the only chunk in the stream).
# Does not preclude a client from reading data from a partially completed response.

== Persistent representations ==

DAP4 defines only two core responses that represent all of the information in a dataset: The Dataset and Data. (See the [[DAP4 Web Services]] document for a complete list of response objects - both required and suggested.)
;Dataset: The ''Dataset'' response is requested by appending the suffix '''''.xml''''' to the ''file part'' of the dataset's referent (aka base) URL. The ''Dataset'' response is an XML document that contains all of the metadata included in the original dataset.
;Data: The ''Data'' response is requested by appending the suffix '''''.dap''''' to the ''file part'' of the dataset's referent (aka base) URL. The ''Data'' response is a multipart MIME document that contains a N+1 parts for a response with N variables.&lt;!-- The document starts with a preamble (i.e., 'part' in MIME parlance) that contains a link to the ''Dataset'' response (which contains the dataset's metadata) followed by N parts which contain the name and type of the data, the data, encoded in XDR, and a checksum. Each of these three pieces of information is separated by a newline. All character data is assumed to be UTF8 encoded. [a little to much detail here, I think ~~~] --&gt;

=== Dataset Metadata Response ===

In DAP2, there existed important information was present only in the HTTP headers. In DAP4, all of the information specified by the protocol will be present in the Dataset Metadata Response (DMR) document. Some of that information may also be present in HTTP headers when it's appropriate, because doing so simplifies processing the response.

==== Document Organization ====

In DAP4 the DAP2 data model has been be extended to include many new concepts and components. Groups, Shared dimensions and user-defined types are just a few of the new additions. For a more complete discussion see the  [[DAP4:_Data_Model | new data model]].

A rough syntax which describes how these additions will fit into the DAP and the existing Dataset notation is:

&lt;font size="2"&gt;
&lt;pre&gt;
Dataset :== Groups
Groups :== null | Group Groups
Group :== SharedDimensions Attributes Groups Variables 
Dimensions :== null | SharedDimension Dimensions
Attributes :== null | Attribute Attributes
Variables :== null | Variable Variables
&lt;/pre&gt;
&lt;/font&gt;

This pseudo-grammar does not capture what can be produced for a ''Group'', et cetera. Instead it shows how these sections of the &lt;Dataset/&gt; document must be organized.

An XML schema for the Dataset response object may be found here: http://scm.opendap.org/trac/browser/trunk/xml/dap/dap4.xsd

NB: If a &lt;Dataset/&gt; document describes a dataset that has been constrained, attributes will not be included. It is not possible to know if attributes correctly describe the data once it has been constrained.

==== The Dataset Element ====

The ''Dataset'' element is the root element of the Dataset response.

The ''Dataset'' element has the following attributes:
;name
:The name of the dataset. This can be any name the server chooses. This should probably be the name of the file or database table/token.

;version
:The version of DAP used by the server to form this Dataset. This must be in int dot int form (e.g., "3.2", "4.11").

;&lt;nowiki&gt;xml:base&lt;/nowiki&gt;
:The value of the ''xml:base'' attribute is the URL which was dereferenced to get this Dataset. The ''xml'' namespace should also be declared in the ''Dataset'' element.

NB: Because the &lt;Dataset/&gt; element, as defined by the schema, uses the Dublin Core, XLink and XML namespaces, those must be present in the element or elsewhere in the document (although, of course, you don't have to use the prefixes ''dc'', ''xlink'' and ''xml'', please do use them and please do define the namespaces in the &lt;Dataset/&gt; element). As with any XML document, you can define other namespaces anywhere they are needed.

Here's an example of the ''Dataset'' element declaration:
&lt;font size="2"&gt;
&lt;source lang="xml"&gt;
&lt;Dataset name="fnoc1.nc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xml.opendap.org/ns/DAP/4.0#  http://xml.opendap.org/dap/dap4.xsd"
    xmlns="http://xml.opendap.org/ns/DAP/4.0#"
    xmlns:dap="http://xml.opendap.org/ns/DAP/4.0#"
    dapVersion="4.0"
    xmlns:xml="http://www.w3.org/XML/1998/namespace"
    xml:base="http://test.opendap.org/opendap/data/nc/fnoc1.nc.ddx"
    xmlns:xlink="..."
    xmlns:dc="..."
&gt;
.
.
.
&lt;/Dataset&gt;
&lt;/source&gt;
&lt;/font&gt;

=== Data Response ===

A Data response is the way DAP4 returns data to a client. Each Data response is returned over the wire as a multipart MIME document where the first MIME part contains the ''constrained'' Dataset Metadata response describing the data requested and the following MIME part contains the binary encoded data values for each variable in the dataset. MIME headers are included in the binary part the identify the endianness of the binary content.

Some aspects of this design have been borrowed from the W3C's "[http://www.w3.org/TR/SOAP-attachments SOAP Messages with Attachments]" and the OGC's "WCS Version 1.1 Corrigendum 2" specifications. See also [http://www.ietf.org/rfc/rfc2387.txt The MIME Multipart/Related Content-type (rfc 2387)] and [http://www.ietf.or/rfc/rfc1521.txt MIME part one].

:In DAP2 the 'data' or 'DataDDS' response is a MIME document with Content-Type 'application/octet-stream' which means essentially that the contents of the MIME document are binary and application specific, in this case specific to applications the understand DAP2. Within that dcoument, the DDS is used to provide the syntax needed to decode the binary information. Following the DDS is a separator and following that are data values written to the document using XDR.

:The use of XDR is solely to ensure that the data values can be read on both little- and big-endian machines and that floating-point values do not suffer from the many different representations commonly found. In additon, XDR is used to include information about the size of arrays, string ans URLs, the latter two of which are really special case arry types. Thus XDR provides a common encoding for the bits and bytes to be transferred. It does not. however, represent any of the more complex structural information such as the organization of relational data.

:The DDS sent with the DataDDS response is used to describe the organization of the data not covered by XDR. For example, if the response calls for values from three variables to be returned, the DDS in the DataDDS response will list those three variables and, furthermore, do so in the order that their values appear in the response. The variables described in the DDS response match ''exactly'' in number, type, shape and order with the data in the 'data part' of the response.

The Data response follows the basic design of DAP2's DataDDS response closely. The Dataset document included describes the number, type, shape and order of each variable with values in the binary part of the response. However, while the DAP2 response used a simple ''application/octet-stream'' document, DAP4 uses a multipart MIME document. The design of this document/response can accommodate including including several different data requests in one document, a feature useful for implementations of DAP that do  not use HTTP for transport.

==== Response Chunking Of Binary Data Part ====

The binary part of the DAP4 Data Response will be chunked, independently of any chunking utilized by underlying protocols such as HTTP. This chunking is essentially is a message based communications scheme. Messages are sent in chunks and handled by the recipient. Out-of-band information can be passed via the extension chunks. The information contained in the extension chunks MAY be used to change the meaning/context of subsequent data chunks. For now we will only be sending Errors in the extension chunks.

[[DAP4 Chunking | The details of DAP4 Chunking are here.]]

This chunking schema provides the following desired outcomes:

# It provides a way for the server to send errors to the client in an out-of-band manner.
# It allows clients to know exactly how many bytes they can expect to read without a server (as opposed to a connection) error.
# It allows the client software to be in a position to deal with error messages as they arise, and easily locate the error content in the input stream.
# Because all messages are chunked, even errors generated by, say, the parseing of the constraint expression can be returned to the client in an error chunk (as the only chunk in the stream).
# Does not preclude a client from reading data from a partially completed response.

==== Transmitting Attributes in constrained Dataset documents  ====

The Dataset document contained in a constrained Dataset or in the Data response will not contain any ''Attribute'' nodes. (The Dataset document in the Data response is always 'constrained'.)

Since the contents of the Data response are the result of access to the data subject to a constraint, various aspects of any of the variables in the response may have been changed. To make these changes the DAP must take into account the semantics of each of the variables' data types. It can do this because the semantics for the types are well defined and known a priori. However, this is not the case for attributes, where the semantics are intentionally not part of the DAP. The DAP is merely an 'envelope' for the name-type-value tuples of the attributes. 

To understand why this restriction is placed on the Dataset document returned in the Data response, lets examine a common example. Suppose an image has some extent and has attributes that name that extent. A geographical image might have attributes that provide the latitude and longitude of two opposite corners and a medial image might have attributes that provide the height and width in millimeters. Now suppose the image is constrained in one or more dimensions, how should the attribute values be treated? If they are left alone they are likely no longer correct but to modify them requires detailed information about how they map to the image and while this information might be know to a client that has an understanding of a particular subject area, expecting the server to handle them correctly would require it to know about every subject area for all of the data to be served.

An alternative to 'universal knowledge' is to allow servers to return attributes that have 'well known' semantics and drop other attributes. While this is appealing at first, it presents a complex situation to clients because to make use of the attributes in the return DataDDX response they must know to test for them and if not present, fallback to some default behavior. In our opinion, it is easier to present clients with fewer 'optional behaviors', especially when the fallback is likely to compute the needed value anyway.

==== Organization of the multipart MIME document ====

Here's what the shell of the document looks like:

&lt;font size="2"&gt;
&lt;pre&gt;
   Content-Type: multipart/related; type="application/vnd.org.opendap.dap4.data"; start="&lt;&lt;start id&gt;&gt;";  boundary="&lt;&lt;boundary&gt;&gt;"
 
   --&lt;&lt;boundary&gt;&gt;
   Content-Type: application/vnd.org.opendap.dap4.dataset-metadata+xml; charset=UTF-8
   Content-Transfer-Encoding: binary
   Content-Id: &lt;&lt;start id&gt;&gt;
   Content-Description: ddx

   &lt;&lt;Dataset document here. This includes a reference to &lt;&lt;data id&gt;&gt; &gt;&gt;

   --&lt;&lt;boundary&gt;&gt;
   Content-Type: application/vnd.org.opendap.dap4.data.big-endian
   Content-Transfer-Encoding: binary
   Content-Id: &lt;&lt;data id&gt;&gt;
   Content-Description: data
   
   &lt;&lt;Binary data&gt;&gt;
      
   --&lt;&lt;boundary&gt;&gt;
&lt;/pre&gt;
&lt;/font&gt;

The example shows three sets of MIME headers separated by three &lt;font size="2"&gt;&lt;code&gt;--&lt;&lt;boundary&gt;&gt;&lt;/code&gt;&lt;/font&gt; lines; the third boundary line terminates the document. The first group of headers (in a real response, there would be other headers here like Date, XDAP, and others) provide information need to recognize the boundary separators and to find the first part of the document by matching the value of ''start'' to a Content-Id of one of the parts. The payload of that first part contains references to the related parts using the values of their Content-Id headers. 

The Dataset document in the first part is unlike the one sent as it's own response in that it 
# Contains no Attribute objects.
# Each DAP4 variable declaration will contain an xlink:href whose value is the value of the Content-Id of the MIME part containing the XDR encoded binary data for the variable.

==== Choosing values for the Data document Content-Ids and Boundaries ====

We would like the software that builds these Data responses to be compatible with as many different transport protocols as possible, so long as the cost to the implementation for which we know we must support is low. One thing that some transport protocols may do is combine several Data responses into a single document and, while the specifics of that will vary between protocols, one choice we can make now that will facilitate that is to ensure that the values of the Content-Ids and &lt;&lt;boundary&gt;&gt;s are unique within and across systems. This will free software that combines Data responses from having to process the Dataset document and Content-Id header to  ensure that no name collisions are present. While using UUIDs, for example, makes the result values 'ugly', it adds virtually nothing to the time needed to build or process the responses. Other schemes, that combine a URI with some system-generated token could also be employed. The important point is to ensure that these symbols are unique not only within a system, but across systems.

==== Changes to the encoding of data ====

There are some issues with the way data values are encoded in DAP2 that we can address now.

# Arrays are prefixed with their sizes, the total number of elements, ''twice'' in DAP 2 because of an initial misuse of the xdr library. Now is the time to fix that and have just one copy of the Array size in DAP 4.
# Sequences are encoded in a way that's optimal but which requires fairly complex Constraint expression evaluation. We can reduce the likelihood that servers fail to implement the Selection sub-expression evaluation by simplifying it a bit. 
# We can embed tags in the binary data to make it easier to read.

=== Error Response ===

An unsuccessful DAP4 request will cause the server to return a DAP4 error response. The error response may be returned in lieu of the Dataset response, or as part of the Data response. The XML used in the Error response is detailed in the DAP4 schema.

DAP4 Data responses are chunked and DAP4 errors always appear in an error chunk. As the client processes a DAP4 response it reads the (fixed length) chunk header prior to reading the chunk. The chunk header will signal to the client that the following chunk contains a DAP4 error. This enables the client to transition to an error processing state prior to ingesting  the error. This is true even if the response contains only an error chunk.

==== Internal Error ====
The error is internal to the Server, most likely a programming bug/issue.

;Example
:&lt;font size="2"&gt;
&lt;source lang="xml"&gt;
&lt;Error type="Internal"&gt;
    &lt;Message&gt;The server encountered a null pointer. Ouch.&lt;/Message&gt;
    &lt;Administrator&gt;admin.email.address@your.domain.name&lt;/Administrator&gt;
&lt;/InternalError&gt;
&lt;/source&gt;
&lt;/font&gt;

==== User Syntax Error ====
The request contains a syntax error in the selection or the projection clause.

;Example
:&lt;font size="2"&gt;
&lt;source lang="xml"&gt;
&lt;Error type="Syntax"&gt;
    &lt;Message&gt;Relational constrains may not be applied to DAP Structures.&lt;/Message&gt;
    &lt;Administrator&gt;admin.email.address@your.domain.name&lt;/Administrator&gt;
&lt;/Error&gt;
&lt;/source&gt;
&lt;/font&gt;

====&lt;strike&gt; Forbidden Error &lt;/strike&gt;====
&lt;strike&gt;The requestor is not allowed to access the resource.

;Example
:&lt;font size="2"&gt;
&lt;source lang="xml"&gt;
&lt;Error type="Forbidden"&gt;
    &lt;Message&gt;The requested resource may not be accessed.&lt;/Message&gt;
    &lt;Administrator&gt;admin.email.address@your.domain.name&lt;/Administrator&gt;
&lt;/Error&gt;
&lt;/source&gt;
&lt;/font&gt;
&lt;/strike&gt;

==== Not Found Error ====
The request resource cannot be found

;Example
:&lt;font size="2"&gt;
&lt;source lang="xml"&gt;
&lt;Error type="NotFound"&gt;
    &lt;Message&gt;Unable to locate resource /data/nc/fnoc10.nc&lt;/Message&gt;
    &lt;Administrator&gt;admin.email.address@your.domain.name&lt;/Administrator&gt;
&lt;/Error&gt;
&lt;/source&gt;
&lt;/font&gt;

== [[DAP4: Asynchronous Responses | Asynchronous Responses]] ==

Rather than duplicating content (and maintaining multiple copies) I have simply moved the content of [[DAP4: Asynchronous Responses  | this section to it's own DAP4 proposal page]]. When it's sorted out and adopted I'll move it back. [[User:Ndp|ndp]] 13:26, 5 April 2012 (PDT)</text>
      <sha1>0a3b65m6wbnctfj9m67e7ovpyys3sbu</sha1>
    </revision>
  </page>
</mediawiki>
